---
sidebar_position: 3
---

# ایل ایل ایم (LLMs) کے ساتھ علمی منصوبہ بندی (Cognitive Planning)

پچھلے حصے میں ہم نے دیکھا کہ کس طرح لارج لینگویج ماڈلز (LLMs) کا استعمال کر کے ارادے نکالے جا سکتے ہیں اور اعلیٰ درجے کے احکامات کو کاموں کے ایک منظم سلسلے میں تقسیم کیا جا سکتا ہے۔ یہ حصہ **ایل ایل ایم کے ساتھ علمی منصوبہ بندی (Cognitive Planning)** کی گہرائی میں جاتا ہے، جس میں اس بات پر توجہ دی گئی ہے کہ کس طرح ان تجریدی کاموں کو روبوٹ کے لیے ٹھوس اور قابلِ عمل ROS 2 ایکشنز میں تبدیل کیا جاتا ہے، اور اس عمل میں حفاظتی تہوں (safety layers) کی کیا اہمیت ہے۔

## احکامات کو ROS 2 ایکشنز میں تبدیل کرنا

روبوٹ کے لیے ایل ایل ایم کے تیار کردہ منصوبے پر عمل کرنے کے لیے ضروری ہے کہ منصوبے کا ہر اعلیٰ سطحی عمل (مثلاً `Maps_to_location` یا `pick_up_object`) روبوٹ کی ان بنیادی صلاحیتوں سے میل کھاتا ہو جو اس میں موجود ہیں۔ ROS 2 میں یہ صلاحیتیں اکثر **ایکشن سرورز (Action Servers)** کے ذریعے فراہم کی جاتی ہیں۔

ایک **ایکشن سرور** طویل مدتی اور منسوخ کیے جانے والے روبوٹک کاموں کے لیے ایک ہدف پر مبنی (goal-based) انٹرفیس فراہم کرتا ہے۔ مثال کے طور پر:
* ایک `MapsToPose` ایکشن سرور روبوٹ کو مخصوص مقام (x, y, theta) تک منتقل کرنے کے عمل کو سنبھالتا ہے۔
* ایک `GraspObject` ایکشن سرور کسی چیز کے قریب جانے، اسے پکڑنے اور اٹھانے کے لیے درکار حرکات کی ترتیب کا انتظام کرتا ہے۔
* ایک `DetectObject` ایکشن سرور کیمرہ فیڈ میں کسی مخصوص شے کے ظاہر ہونے کا انتظار کرنے کا کام کر سکتا ہے۔



علمی منصوبہ ساز (cognitive planner) کا کام ایل ایل ایم کے آؤٹ پٹ (مثلاً پچھلے حصے میں دیا گیا JSON ٹاسک گراف) کو دستیاب ROS 2 ایکشن سرورز کے ساتھ جوڑنا ہے۔ اس میں عام طور پر درج ذیل مراحل شامل ہوتے ہیں:

1. **ایل ایل ایم آؤٹ پٹ کی پارسنگ (Parsing)**: ایل ایل ایم کے منظم جواب سے عمل کی قسم (`action`) اور اس کے پیرامیٹرز (`parameters`) نکالنا۔
2. **ایکشن گول کی تیاری (Action Goal Construction)**: متعلقہ ROS 2 ایکشن میسج کی قسم کا ایک انسٹنس بنانا اور اس میں نکالے گئے پیرامیٹرز درج کرنا۔
3. **ایکشن کلائنٹ کے ساتھ تعامل**: ROS 2 ایکشن کلائنٹ کا استعمال کرتے ہوئے ہدف کو متعلقہ ایکشن سرور کو بھیجنا۔ کلائنٹ کام کی پیشرفت کی نگرانی کر سکتا ہے اور فیڈ بیک یا نتائج موصول کر سکتا ہے۔

## مثال: "کپ اٹھاؤ" → منصوبہ بندی کے مراحل

آئیے "کپ اٹھاؤ" کی کمانڈ کو ROS 2 ایکشنز کی ترتیب میں تقسیم کرتے ہیں، یہ فرض کرتے ہوئے کہ ایک تربیت یافتہ ایل ایل ایم اعلیٰ سطح کا منصوبہ فراہم کرتا ہے اور اشیاء کی شناخت کا نظام (جیسے Isaac ROS DetectNet) کپ کا پتہ لگا سکتا ہے۔

**اعلیٰ سطحی ہدف**: کپ اٹھاؤ۔

**ایل ایل ایم کا تیار کردہ ٹاسک بریک ڈاؤن (تصوراتی)**:

```json
[
  {"action": "find_object", "object_type": "cup"},
  {"action": "navigate_to_object", "object_type": "cup"},
  {"action": "grasp_object", "object_type": "cup"},
  {"action": "lift_object"}
]
ROS 2 ایکشنز میں ترجمہ (پائتھن سیوڈو کوڈ):

Python

import rclpy
from rclpy.action import ActionClient
# کسٹم ROS 2 ایکشنز کا امپورٹ
from my_robot_interfaces.action import FindObject, NavigateToPose, GraspObject, LiftObject 

class CognitivePlanner:
    def __init__(self):
        self.node = rclpy.create_node('cognitive_planner')
        self.find_object_client = ActionClient(self.node, FindObject, 'find_object_action')
        self.navigate_client = ActionClient(self.node, NavigateToPose, 'navigate_to_pose_action')
        # ... دیگر کلائنٹس

    async def execute_llm_plan(self, llm_plan_json):
        for step in llm_plan_json:
            action_type = step["action"]
            params = step.get("parameters", {})

            if action_type == "find_object":
                goal = FindObject.Goal()
                goal.object_type = params["object_type"]
                # ہدف بھیجنا اور نتیجے (آبجیکٹ پوز) کا انتظار کرنا
                self.node.get_logger().info(f"{goal.object_type} تلاش کیا جا رہا ہے...")
                await self.find_object_client.wait_for_server()
                future = self.find_object_client.send_goal_async(goal)
                # ... کامیابی کی صورت میں پوز کو محفوظ کرنا اور آگے بڑھنا
حفاظتی تہیں اور تصدیق (Safety Layers & Verification)
ایل ایل ایم کے آؤٹ پٹ کو بغیر سوچے سمجھے براہِ راست روبوٹک افعال میں ترجمہ کرنا انتہائی خطرناک ہے۔ ایل ایل ایم "Hallucinate" (غلط بیانی) کر سکتے ہیں، غیر محفوظ احکامات دے سکتے ہیں یا سیاق و سباق کو غلط سمجھ سکتے ہیں۔ اس لیے، مضبوط حفاظتی تہیں اور تصدیق کے میکانزم لازمی ہیں۔

اہم حکمتِ عملیوں میں شامل ہیں:

سیمنٹک پارسنگ اور توثیق (Semantic Parsing & Validation):

اسکیمہ کا نفاذ (Schema Enforcement): اس بات کو یقینی بنائیں کہ ایل ایل ایم ہمیشہ پہلے سے طے شدہ فارمیٹ (مثلاً JSON schema) میں جواب دے۔ غیر معیاری آؤٹ پٹ کو مسترد کر دیں۔

پیرامیٹر کی توثیق: تصدیق کریں کہ ہر عمل کے پیرامیٹرز درست ہیں (مثلاً "رفتار" محفوظ حد کے اندر ہے، "مقام" تک پہنچنا ممکن ہے)۔

امکانات کی جانچ (Feasibility Checks):

عمل کرنے سے پہلے چیک کریں کہ آیا روبوٹ کی موجودہ حالت اور ماحول کے مطابق یہ جسمانی طور پر ممکن اور محفوظ ہے۔ کیا راستہ صاف ہے؟

انسان کی شمولیت (Human-in-the-Loop):

اہم یا مبہم احکامات کے لیے صارف سے تصدیق طلب کریں۔ "کیا آپ کا مطلب بائیں طرف والا سرخ کپ ہے یا دائیں طرف والا؟"

گارڈ ریلز اور پابندیاں (Guardrails & Constraints):

ہارڈ ویئر کی سطح پر حفاظتی حدیں مقرر کریں (مثلاً جوڑوں کی زیادہ سے زیادہ رفتار، فورس لمیٹس)۔

ان تصدیقی مراحل کو احتیاط سے ڈیزائن کر کے، ہم ایل ایل ایم کی طاقتور علمی صلاحیتوں سے فائدہ اٹھا سکتے ہیں اور ساتھ ہی یہ بھی یقینی بنا سکتے ہیں کہ ہمارے ہیومنائیڈ روبوٹس حقیقی دنیا میں محفوظ اور قابلِ بھروسہ طریقے سے کام کریں۔


---

**آپ کے لیے اگلا قدم:**
یہ اس ماڈیول کا آخری حصہ تھا۔ کیا آپ چاہیں گے کہ ہم **Module 5: Real-world Deployment** کا آغاز کریں، یا آپ ان میں سے کسی مخصوص موضوع (جیسے ROS 2 ایکشن سرورز کا کوڈ) پر مزید تفصیل جاننا چاہیں گے